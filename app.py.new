import streamlit as st
import random
import time
import json
import os
from streamlit_autorefresh import st_autorefresh
from game_logic import Game, Player
from data import DOMAINS, get_items_for_domain

# Page config
st.set_page_config(
    page_title="Imposter / Ø¨Ø±Ù‘Ù‡ Ø§Ù„Ø³Ø§Ù„ÙØ©",
    page_icon="ğŸ²",
    layout="wide"
)

# Initialize session state
if 'game' not in st.session_state:
    st.session_state.game = None

# Create a directory for storing game states if it doesn't exist
os.makedirs('game_states', exist_ok=True)

def save_game_state(game):
    """Save game state to file"""
    if game:
        game_data = {
            'room_code': game.room_code,
            'phase': game.phase,
            'players': [{'name': p.name, 'is_host': p.is_host, 'score': p.score} for p in game.players],
            'min_players': game.min_players,
            'current_domain': game.current_domain,
            'current_item': game.current_item,
            'imposter': game.imposter.name if game.imposter else None,
            'discussion_end_time': game.discussion_end_time,
            'votes': game.votes,
            'most_voted_player': game.most_voted_player,
        }
        with open(f'game_states/{game.room_code}.json', 'w') as f:
            json.dump(game_data, f)

def load_game_state(room_code):
    """Load game state from file"""
    try:
        with open(f'game_states/{room_code}.json', 'r') as f:
            data = json.load(f)
            game = Game(data['room_code'])
            game.phase = data['phase']
            
            # Recreate players
            for p_data in data['players']:
                player = Player(p_data['name'], p_data['is_host'])
                player.score = p_data['score']
                game.add_player(player)
            
            game.min_players = data['min_players']
            game.current_domain = data['current_domain']
            game.current_item = data['current_item']
            
            # Set imposter
            if data['imposter']:
                game.imposter = next((p for p in game.players if p.name == data['imposter']), None)
            
            game.discussion_end_time = data['discussion_end_time']
            game.votes = data['votes']
            game.most_voted_player = data['most_voted_player']
            
            return game
    except FileNotFoundError:
        return None

def sync_game_state():
    """Sync game state with the stored state"""
    if st.session_state.game and hasattr(st.session_state.game, 'room_code'):
        stored_game = load_game_state(st.session_state.game.room_code)
        if stored_game:
            # Check if there's any change in game state
            current_phase = st.session_state.game.phase
            
            # Always update the game state to ensure synchronization
            st.session_state.game = stored_game
            
            # Show update notification if something changed
            if current_phase != stored_game.phase:
                st.toast(f"Game phase changed to: {stored_game.phase} ğŸ”„")

def create_room():
    """Create a new game room"""
    if not st.session_state.get('player_name'):
        st.error("Please enter your name first")
        return
    
    # Generate room code
    room_code = ''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ', k=4))
    game = Game(room_code)
    game.add_player(Player(st.session_state.player_name, is_host=True))
    st.session_state.game = game
    save_game_state(game)
    st.query_params['room'] = room_code
    st.query_params['name'] = st.session_state.player_name

def join_room():
    """Join an existing game room"""
    if not st.session_state.get('player_name') or not st.session_state.get('room_code'):
        st.error("Please enter both your name and room code")
        return
    
    room_code = st.session_state.room_code.upper()
    game = load_game_state(room_code)
    
    if game is None:
        st.error("Room not found!")
        return
    
    player = Player(st.session_state.player_name)
    game.add_player(player)
    st.session_state.game = game
    save_game_state(game)
    st.query_params['room'] = room_code
    st.query_params['name'] = st.session_state.player_name

def main():
    st.title("Imposter / Ø¨Ø±Ù‘Ù‡ Ø§Ù„Ø³Ø§Ù„ÙØ© ğŸ²")
    st.markdown("<p style='direction: rtl'>Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¯Ø®ÙŠÙ„ ÙÙŠ Ø§Ù„Ù„Ø¹Ø¨Ø©!</p>", unsafe_allow_html=True)
    
    # Get query parameters and sync state
    if 'room' in st.query_params and 'name' in st.query_params:
        st.session_state.room_code = st.query_params['room']
        st.session_state.player_name = st.query_params['name']
        
        # Try to load existing game
        if st.session_state.game is None:
            stored_game = load_game_state(st.session_state.room_code)
            if stored_game:
                st.session_state.game = stored_game
    
    # Auto-refresh the page every 2 seconds
    count = st_autorefresh(interval=2000, key="game_refresh")
    sync_game_state()
    
    if st.session_state.game is None:
        # Login screen with instructions
        st.write("### How to Play / Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù„Ø¹Ø¨:")
        st.write("1. One player creates a room and becomes the host / ÙŠÙ‚ÙˆÙ… Ù„Ø§Ø¹Ø¨ Ø¨Ø¥Ù†Ø´Ø§Ø¡ ØºØ±ÙØ© ÙˆÙŠØµØ¨Ø­ Ø§Ù„Ù…Ø¶ÙŠÙ")
        st.write("2. Other players join using the room code / ÙŠÙ†Ø¶Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ÙˆÙ† Ø§Ù„Ø¢Ø®Ø±ÙˆÙ† Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø±Ù…Ø² Ø§Ù„ØºØ±ÙØ©")
        st.write("3. The host starts the game when enough players have joined / ÙŠØ¨Ø¯Ø£ Ø§Ù„Ù…Ø¶ÙŠÙ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙ†Ø¶Ù… Ø¹Ø¯Ø¯ ÙƒØ§ÙÙ Ù…Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†")
        st.divider()
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("ğŸ² Create New Room / Ø¥Ù†Ø´Ø§Ø¡ ØºØ±ÙØ© Ø¬Ø¯ÙŠØ¯Ø©")
            st.write("Choose this if you want to host a game / Ø§Ø®ØªØ± Ù‡Ø°Ø§ Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ±ÙŠØ¯ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ù…Ø¶ÙŠÙ")
            player_name = st.text_input("Your Name / Ø§Ø³Ù…Ùƒ:", key="create_name", placeholder="Enter your name / Ø£Ø¯Ø®Ù„ Ø§Ø³Ù…Ùƒ")
            if st.button("ğŸ® Create Room & Become Host / Ø¥Ù†Ø´Ø§Ø¡ ØºØ±ÙØ© ÙˆÙƒÙ† Ø§Ù„Ù…Ø¶ÙŠÙ", use_container_width=True):
                st.session_state.player_name = player_name
                create_room()
        
        with col2:
            st.subheader("ğŸ® Join Existing Room / Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø¥Ù„Ù‰ ØºØ±ÙØ© Ù…ÙˆØ¬ÙˆØ¯Ø©")
            st.write("Choose this to join someone else's game / Ø§Ø®ØªØ± Ù‡Ø°Ø§ Ù„Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø¥Ù„Ù‰ Ù„Ø¹Ø¨Ø© Ø´Ø®Øµ Ø¢Ø®Ø±")
            room_code = st.text_input("Room Code / Ø±Ù…Ø² Ø§Ù„ØºØ±ÙØ©:", key="join_room_code", placeholder="Enter 4-letter code / Ø£Ø¯Ø®Ù„ Ø±Ù…Ø² Ù…Ù† 4 Ø£Ø­Ø±Ù", max_chars=4)
            player_name = st.text_input("Your Name / Ø§Ø³Ù…Ùƒ:", key="join_name", placeholder="Enter your name / Ø£Ø¯Ø®Ù„ Ø§Ø³Ù…Ùƒ")
            if st.button("ğŸ‘¥ Join Room / Ø§Ù†Ø¶Ù… Ù„Ù„ØºØ±ÙØ©", use_container_width=True):
                st.session_state.player_name = player_name
                st.session_state.room_code = room_code
                join_room()
    
    else:
        game = st.session_state.game
        
        # Main layout - more mobile friendly
        st.subheader("ğŸ† Scoreboard / Ø§Ù„Ù†ØªØ§Ø¦Ø¬")
        # Sort players by score in descending order
        sorted_players = sorted(game.players, key=lambda x: x.score, reverse=True)
        
        # Show your score prominently
        for player in sorted_players:
            if player.name == st.session_state.player_name:
                st.markdown(f"**You / Ø£Ù†Øª:** {player.score} Ù†Ù‚Ø·Ø©")
            else:
                st.write(f"{player.name}: {player.score} Ù†Ù‚Ø·Ø©")
        
        # Room info
        st.divider()
        st.write(f"Room Code / Ø±Ù…Ø² Ø§Ù„ØºØ±ÙØ©: {game.room_code} | Players / Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†: {len(game.players)}")
        if game.current_domain:
            st.write(f"Domain / Ø§Ù„Ù…Ø¬Ø§Ù„: {game.current_domain}")
        st.divider()

        # Game phases
        if game.phase == "lobby":
            st.subheader("Lobby / Ø§Ù„ØºØ±ÙØ©")
            st.write("Players in the room / Ø§Ù„Ù„Ø§Ø¹Ø¨ÙˆÙ† ÙÙŠ Ø§Ù„ØºØ±ÙØ©:")
            for player in game.players:
                st.write(f"- {player.name} {'(Host / Ø§Ù„Ù…Ø¶ÙŠÙ)' if player.is_host else ''}")
            
            # Show lobby status
            st.write(f"Number of players / Ø¹Ø¯Ø¯ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†: {len(game.players)} (Minimum needed / Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: {game.min_players})")
            
            # Host controls
            if game.is_player_host(st.session_state.player_name):
                st.write("ğŸ‘‘ You are the host / Ø£Ù†Øª Ø§Ù„Ù…Ø¶ÙŠÙ")
                test_mode = st.checkbox("Enable Test Mode (2 players minimum) / ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± (Ù„Ø§Ø¹Ø¨ÙŠÙ† ÙƒØ­Ø¯ Ø£Ø¯Ù†Ù‰)")
                if test_mode:
                    game.min_players = 2
                    save_game_state(game)
                
                if len(game.players) >= game.min_players:
                    if st.button("â–¶ï¸ Start Round / Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¬ÙˆÙ„Ø©"):
                        game.start_round()
                        save_game_state(game)
                        st.rerun()
                else:
                    st.warning(f"Need {game.min_players - len(game.players)} more players to start / Ù†Ø­ØªØ§Ø¬ {game.min_players - len(game.players)} Ù„Ø§Ø¹Ø¨ Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„Ø¨Ø¯Ø¡")
            else:
                st.info("Waiting for the host to start the game... / Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…Ø¶ÙŠÙ Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©...")
        
        elif game.phase == "round_setup":
            st.subheader("ğŸ‘‘ Host: Select Domain / Ø§Ù„Ù…Ø¶ÙŠÙ: Ø§Ø®ØªØ± Ø§Ù„Ù…Ø¬Ø§Ù„")
            
            if game.is_player_host(st.session_state.player_name):
                st.write("Choose a category for this round / Ø§Ø®ØªØ± ÙØ¦Ø© Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø¬ÙˆÙ„Ø©:")
                domain = st.selectbox("Available domains / Ø§Ù„Ù…Ø¬Ø§Ù„Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©:", DOMAINS, index=0)
                if st.button("âœ… Start Round with Selected Domain / Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¬ÙˆÙ„Ø© Ø¨Ø§Ù„Ù…Ø¬Ø§Ù„ Ø§Ù„Ù…Ø®ØªØ§Ø±"):
                    game.set_domain(domain)
                    game.select_item()
                    game.start_discussion()
                    save_game_state(game)
                    st.rerun()
            else:
                st.info("ğŸ’­ Waiting for the host to select a domain... / Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…Ø¶ÙŠÙ Ù„Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø¬Ø§Ù„...")
        
        elif game.phase == "discussion":
            st.subheader("Discussion Phase / Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù†Ù‚Ø§Ø´")
            
            # Display role and item
            player_role = "Imposter / Ø§Ù„Ø¯Ø®ÙŠÙ„!" if game.is_player_imposter(st.session_state.player_name) else f"Regular Player / Ù„Ø§Ø¹Ø¨ Ø¹Ø§Ø¯ÙŠ (Item / Ø§Ù„Ø¹Ù†ØµØ±: {game.current_item})"
            st.info(f"You are / Ø£Ù†Øª: {player_role}")
            
            # Chat/Discussion area
            st.write("Use this time to ask questions and discuss! / Ø§Ø³ØªØ®Ø¯Ù… Ù‡Ø°Ø§ Ø§Ù„ÙˆÙ‚Øª Ù„Ø·Ø±Ø­ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© ÙˆØ§Ù„Ù…Ù†Ø§Ù‚Ø´Ø©!")
            
            # Timer
            time_left = max(0, game.discussion_end_time - time.time())
            st.progress(time_left / game.discussion_duration)
            st.write(f"Time remaining / Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: {int(time_left)} seconds / Ø«Ø§Ù†ÙŠØ©")
            
            if game.is_player_host(st.session_state.player_name):
                if st.button("End Discussion & Open Voting / Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù†Ù‚Ø§Ø´ ÙˆØ¨Ø¯Ø¡ Ø§Ù„ØªØµÙˆÙŠØª"):
                    game.start_voting()
                    save_game_state(game)
                    st.rerun()
        
        elif game.phase == "voting":
            st.subheader("Voting Phase / Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªØµÙˆÙŠØª")
            
            if not game.has_player_voted(st.session_state.player_name):
                st.write("Who do you think is the Imposter? Choose carefully! / Ù…Ù† ØªØ¹ØªÙ‚Ø¯ Ø£Ù†Ù‡ Ø§Ù„Ø¯Ø®ÙŠÙ„ØŸ Ø§Ø®ØªØ± Ø¨Ø¹Ù†Ø§ÙŠØ©!")
                st.warning("Remember: You'll get 100 points if you guess correctly! / ØªØ°ÙƒØ±: Ø³ØªØ­ØµÙ„ Ø¹Ù„Ù‰ 100 Ù†Ù‚Ø·Ø© Ø¥Ø°Ø§ Ø®Ù…Ù†Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­!")
                
                for player in game.players:
                    if player.name != st.session_state.player_name:
                        if st.button(f"Vote for / ØµÙˆÙ‘Øª Ù„Ù€ {player.name}"):
                            game.submit_vote(st.session_state.player_name, player.name)
                            save_game_state(game)
                            st.rerun()
            else:
                your_vote = game.votes.get(st.session_state.player_name)
                st.info(f"You voted for / Ù„Ù‚Ø¯ ØµÙˆÙ‘Øª Ù„Ù€: {your_vote}")
                st.write("Waiting for other players to vote... / Ø¨Ø§Ù†ØªØ¸Ø§Ø± ØªØµÙˆÙŠØª Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†...")
            
            total_votes = len(game.votes)
            total_players = len(game.players)
            st.progress(total_votes / total_players)
            st.write(f"Votes / Ø§Ù„Ø£ØµÙˆØ§Øª: {total_votes}/{total_players}")
            
            if game.all_votes_submitted():
                game.reveal_imposter()
                save_game_state(game)
                st.rerun()
        
        elif game.phase == "reveal":
            st.subheader("Results / Ø§Ù„Ù†ØªØ§Ø¦Ø¬")
            st.write(f"The Imposter was / ÙƒØ§Ù† Ø§Ù„Ø¯Ø®ÙŠÙ„ Ù‡Ùˆ: {game.imposter.name}")
            
            # Show individual results
            st.write("\nVoting Results / Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØªØµÙˆÙŠØª:")
            correct_voters = []
            for player in game.players:
                if game.did_player_vote_correctly(player.name):
                    correct_voters.append(player.name)
                    if player.name == st.session_state.player_name:
                        st.success(f"ğŸ‰ Excellent! You identified the Imposter correctly! / Ù…Ù…ØªØ§Ø²! Ù„Ù‚Ø¯ Ø­Ø¯Ø¯Øª Ø§Ù„Ø¯Ø®ÙŠÙ„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­! +100 Ù†Ù‚Ø·Ø©")
                    else:
                        st.success(f"âœ… {player.name} identified the Imposter correctly / Ø­Ø¯Ø¯ Ø§Ù„Ø¯Ø®ÙŠÙ„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ (+100 Ù†Ù‚Ø·Ø©)")
                else:
                    if player.name == st.session_state.player_name:
                        if player.name in game.votes:
                            voted_for = game.votes[player.name]
                            st.error(f"âŒ You guessed / Ø®Ù…Ù†Øª {voted_for}, but it was incorrect / Ù„ÙƒÙ†Ù‡ ÙƒØ§Ù† Ø®Ø·Ø£")
                        else:
                            st.warning("âš ï¸ You didn't vote / Ù„Ù… ØªØµÙˆØª")
            
            if game.is_player_host(st.session_state.player_name):
                if st.button("Proceed to Imposter Guess / Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø¥Ù„Ù‰ ØªØ®Ù…ÙŠÙ† Ø§Ù„Ø¯Ø®ÙŠÙ„"):
                    game.start_imposter_guess()
                    save_game_state(game)
                    st.rerun()
        
        elif game.phase == "imposter_guess":
            st.subheader("Imposter's Guess / ØªØ®Ù…ÙŠÙ† Ø§Ù„Ø¯Ø®ÙŠÙ„")
            
            if game.is_player_imposter(st.session_state.player_name):
                st.write("Choose the item you think everyone else was discussing: / Ø§Ø®ØªØ± Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ø°ÙŠ ØªØ¹ØªÙ‚Ø¯ Ø£Ù† Ø§Ù„Ø¬Ù…ÙŠØ¹ ÙƒØ§Ù† ÙŠÙ†Ø§Ù‚Ø´Ù‡:")
                options = game.get_guess_options()
                
                for option in options:
                    image_path = f"item_images/{option.lower().replace(' ', '_')}.png"
                    if os.path.exists(image_path):
                        st.image(image_path, caption=f"{option}", width=200)
                    
                    if st.button(f"{option}", key=f"guess_{option}"):
                        game.submit_imposter_guess(option)
                        if option == game.current_item:
                            st.success("ğŸ¯ You got it! / Ø£Ø­Ø³Ù†Øª! +100 Ù†Ù‚Ø·Ø©")
                        else:
                            st.error(f"âŒ Wrong! The correct item was / Ø®Ø·Ø£! Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„ØµØ­ÙŠØ­ ÙƒØ§Ù†: {game.current_item}")
                        game.show_scores()
                        save_game_state(game)
                        st.rerun()
            else:
                st.write("Waiting for the Imposter to make their guess... / Ø¨Ø§Ù†ØªØ¸Ø§Ø± ØªØ®Ù…ÙŠÙ† Ø§Ù„Ø¯Ø®ÙŠÙ„...")
                st.info(f"The item was / Ø§Ù„Ø¹Ù†ØµØ± ÙƒØ§Ù†: {game.current_item}")
                image_path = f"item_images/{game.current_item.lower().replace(' ', '_')}.png"
                if os.path.exists(image_path):
                    st.image(image_path, caption=game.current_item, width=200)
        
        elif game.phase == "scores":
            st.subheader("Round Complete! / Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ø¬ÙˆÙ„Ø©!")
            
            if game.imposter_guess == game.current_item:
                st.success(f"ğŸ¯ The Imposter ({game.imposter.name}) won! / ÙØ§Ø² Ø§Ù„Ø¯Ø®ÙŠÙ„!")
                st.write(f"Correctly guessed / Ø®Ù…Ù‘Ù† Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­: {game.current_item}")
            else:
                st.error(f"The Imposter ({game.imposter.name}) lost! / Ø®Ø³Ø± Ø§Ù„Ø¯Ø®ÙŠÙ„!")
                st.write(f"The item was / Ø§Ù„Ø¹Ù†ØµØ± ÙƒØ§Ù†: {game.current_item}")
            
            if game.is_player_host(st.session_state.player_name):
                st.write("Host Controls / ØªØ­ÙƒÙ… Ø§Ù„Ù…Ø¶ÙŠÙ:")
                col1, col2 = st.columns(2)
                with col1:
                    if st.button("Next Round (Same Domain) / Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© (Ù†ÙØ³ Ø§Ù„Ù…Ø¬Ø§Ù„)", key="same_domain"):
                        current_domain = game.current_domain
                        game.reset_round()
                        game.current_domain = current_domain
                        game.select_item()
                        game.start_discussion()
                        save_game_state(game)
                        st.rerun()
                
                with col2:
                    if st.button("Next Round (New Domain) / Ø§Ù„Ø¬ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© (Ù…Ø¬Ø§Ù„ Ø¬Ø¯ÙŠØ¯)", key="new_domain"):
                        game.reset_round()
                        save_game_state(game)
                        st.rerun()
                
                if st.button("End Game / Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©", key="end_game"):
                    game.reset_game()
                    save_game_state(game)
                    st.rerun()

if __name__ == "__main__":
    main()
